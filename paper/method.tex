
\section{Methodology}
\label{sec:method}

\subsection{Link IO together}

Normally, when using Libfuzzer, we put the source code need to be test inside \texttt{LLVMFuzzerTestOneInput} as describe in the introduction section.
But when we want to run a binary, we don't have source code.
Hence, what we do is actually putting \texttt{execv("our-binary", ..., ...)} inside the \texttt{LLVMFuzzerTestOneInput} to invoke our binary.
And before execute \texttt{execv} we need to use dup2 to link

\begin{enumerate}
  \item [1.] fuzzer test input $\to$ binary stdin.
  \item [2.] binary stdout $\to$ \texttt{/dev/null}.
  \item [3.] binary stderr $\to$ \texttt{/dev/null}
\end{enumerate}

The simplified code is something like below

\begin{lstlisting}[language = c++]
extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {

    int P_IN[2]; pipe(P_IN);
    if(Size) write(P_IN[1], Data, Size);
    ...
    int pid = fork();
    if(pid == 0) {
        dup2(P_IN[0], STDIN_FILENO);
        dup2(dev_null, STDOUT_FILENO);
        dup2(dev_null, STDERR_FILENO);
        ...
        execv(..., ..., ...);
    }
    ...
}
\end{lstlisting}

\subsection{Collect Runtime Information}

After we link IO together, the binary should get the input of the libfuzzer test input now.
Though it is runnable, Libufuzzer don't have any runtime information like code coverage and will stop running after a few rounds.
First, we need to figure out what Libfuzzer collect while running.
Libfuzzer collect runtime information through \textbf{Clang SanitizerCoverage}, which provides simple code coverage instrumentation and has hook function for customization.
Now we use qemu to collect right information for those hook function implemented by LibFuzzer.

\subsubsection{trace pc guard}

LibFuzzer use two array to store the information of code coverage.
\begin{enumerate}
    \item [1.] \texttt{\_\_sancov\_trace\_pc\_pcs} : store the program counter of the beginning of a code block.
    \item [2.] \texttt{\_\_sancov\_trace\_pc\_guard\_8bit\_counters} : store how many times the code block was hit.
\end{enumerate}

\begin{lstlisting}
__sancov_trace_pc_pcs[Idx] = PC;
__sancov_trace_pc_guard_8bit_counters[Idx]++;
\end{lstlisting}

We need to fill those array for LibFuzzer to work.
First, we use radare2 api \textbf{r2pipe} to do static analysis and index those code block.
While doing static analysis with r2pipe, we filter out addresses we don't want, like library code.
Second, we use qemu to check whether we hit a code block, and fill in those value.
The qemu command we use is \texttt{qemu-x86\_64 -D logfile -d in\_asm binary}.
\texttt{in\_asm} provides us the assembly code and its address being executed. ( see example below )

\begin{lstlisting}
...
----------------
IN:
0x0000004000802c90:  mov    %r11,%rcx
0x0000004000802c93:  sub    %rax,%rcx
0x0000004000802c96:  cmp    $0xb,%rcx
0x0000004000802c9a:  ja     0x4000802dd8
...
\end{lstlisting}

After parsing qemu output and fill in those value, LibFuzzer is now runnable.

\subsubsection{trace pc indir}

Indirect call is a call instruction with nonconstant address.
For example, \texttt{call rax}.
Libfuzzer will gather information for indirect call using \texttt{\_\_sanitizer\_cov\_trace\_pc\_indir} hook function.
It needs the address before call, and the address after call.
We implement this hook function in the following steps.

\begin{enumerate}
    \item [1.] Modify qemu source code to output a text message when there is a indirect call.
    \item [2.] When current translation block has a indirect call, we look at the ending address of the current block and the beginning address of the next block, then pass those values to \texttt{fuzzer::TPC.HandleCallerCallee}
\end{enumerate}
